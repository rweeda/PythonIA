<html>

<head>
	<title>SQL - Informatica Actief</title>
    <!--css import-->
    <link rel="stylesheet" href="style.css">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- for rescaling menu -->
	<!-- Add icon library -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

</head>
<body>
  <h1>UITWERKINGEN</h1>
  <hr>
<h1 id="SQL1">Onderwerp 1: Databases</h1>

<hr>
<div class="content">
<h3 id="opgave111">Verwerkingsopdracht 1.1.1 Kolommen kiezen bij het ontwerp van een tabel</h3>
<ol style="list-style-type: lower-alpha">

<li>Deze gegevens worden verzameld: voornaam, tussenvoegsel, achternaam,
adres, postcode, plaats en telefoon.</li>

<li>Dat is een veld dat verplicht ingevuld moet worden.</li>

<li>Als twee klanten dezelfde naam hebben kun je ze niet uit elkaar halen, je
kunt dan niet hun juiste adres opzoeken. Als oplossing gebruiken we een
unieke waarde waarvan er maar één is, zoals een leerlingnummer op school, of
een BSN.</li>

<li>Voor Danilo's pizzeria zou een uniek nummer een klantnummer kunnen zijn.</li>

<li>Zie tabel hieronder.</li>

</ol>


TABEL: klanten <table border="1">
  <thead>
    <tr>
      <th>klantnummer</th>
      <th>voornaam</th>
      <th>tussenvoegsel</th>
      <th>achternaam</th>
      <th>adres</th>
      <th>postcode</th>
      <th>plaats</th>
      <th>telefoon</th>
    </tr>
  </thead>
</table>


<h3 id="opgave121">Verwerkingsopdracht 1.2.1 Verschillende soorten data</h3>
TABEL: klanten <table border="">
  <thead>
    <tr>
      <th>klantnummer</th>
      <th>voornaam</th>
      <th>tussenvoegsel</th>
      <th>achternaam</th>
      <th>adres</th>
      <th>postcode</th>
      <th>plaats</th>
      <th>telefoon</th>
    </tr>
        <tr>
      <td>INTEGER</td>
      <td>TEXT</td>
      <td>TEXT</td>
      <td>TEXT</td>
      <td>TEXT</td>
      <td>TEXT</td>
      <td>TEXT</td>
      <td>TEXT</td>
    </tr>
  </thead>
</table>


<h3 id="opgave122">Verwerkingsopdracht 1.2.2 Datatypes kiezen bij tabel pizza</h3>

<p>Stel nu dat we een tabel met pizza's hebben. De eerste kolom gebruiken we voor unieke code, de tweede voor naam, de derde voor omschrijving en de laatste voor de prijs. Geef aan welke type bij welk kolom hoort. Kies daarvoor uit: TEXT, INTEGER en REAL.</p>


TABEL: pizza <table>
  <thead>
    <tr>
      <th>pizzacode</th>
      <th>naam</th>
      <th>omschrijving</th>
      <th>basisprijs</th>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>TEXT</td>
      <td>TEXT</td>
      <td>REAL</td>
    </tr>
  </thead>
</table>


<h3 id="opgave131">Verwerkingsopdracht 1.3.1 Wat is een primary key?</h3>
Antwoord C is juist. Een primary key identificeert elke rij op unieke wijze


<h3 id="opgave132">Verwerkingsopdracht 1.3.2 Welke kolom is een primary key?</h3>
Kolom <em>klantnummer</em> is de primary key. Elk klant heeft een eigen unieke klantnummer.

<h3 id="opgave141">Verwerkingsopdracht 1.4.1 Eisen aan data stellen bij het ontwerpen van een tabel</h3>


TABEL: klanten <table border="1">
  <thead>
    <tr>
      <th>klantnummer<br>INTEGER PRIMARY KEY NOT NULL</th>
      <th>voornaam<br>TEXT NOT NULL</th>
      <th>tussenvoegsel<br>TEXT</th>
      <th>achternaam<br>TEXT NOT NULL</th>
      <th>adres<br>TEXT NOT NULL</th>
      <th>postcode<br>TEXT NOT NULL</th>
      <th>plaats<br>TEXT NOT NULL</th>
      <th>telefoon<br>TEXT NOT NULL</th>
    </tr>
  </thead>
</table>


<h3 id="opgave151">Verwerkingsopdracht 1.5.1 Waar vind je databases?</h3>
Voorbeelden van databases zijn
<ol style="list-style-type: lower-alpha">
        <li>
                <ul>
                <li>Webwinkel</li>
                <li>Social media platform</li>
                <li>Magister of SOMtoday</li>
                </ul>
        <li>
                <ul>
                <li>Bij webwinkel: productenlijst</li>
                <li>Bij social media platform: posts</li>
                <li>Bij school database: gegevens over leerlingen zoals adres, cijfers en rooster</li>
                </ul>
</ol>


<h3 id="opgave171">Verwerkingsopdracht 1.7.1 CRUD rechten van klanten bepalen</h3>
<ol style="list-style-type: lower-alpha">
<li>Acties:
<ul>
<li>Create: Ja, bij het aanmaken van een nieuw account.
<li>Read: Ja, mag eigen gegevens bekijken.
<li>Update: Ja, mag eigen gegevens wijzigen (zoals wachtwoord of adres).
<li>Delete: Meestal niet zelf; alleen door een beheerder.
</ul>
<li>Klanten mogen alleen hun eigen gegevens zien, invoeren en wijzigen, maar niet verwijderen. Dit voorkomt fouten en misbruik, en beschermt de privacy van andere klanten.
</ol>

<h3 id="opgave172">Verwerkingsopdracht 1.7.2 CRUD Rechten van de bezorger bepalen</h3>
<ol style="list-style-type: lower-alpha">
<li>Acties:
<ul>
<li>Read: Ja, om te kunnen zien welke bestellingen hij moet bezorge naar welk adres.
<li>Update: Ja, om de bezorgtijd vast te leggen.
<li>Create/Delete: Nee, een bezorger mag geen bestellingen invoeren of verwijderen.
</ul>
<li>Toelichting: De bezorger heeft beperkte toegang. Hij mag alleen de bezorg_tijd aangeven, en dus aanpassen. Andere gegevens zijn niet zijn verantwoordelijkheid en moeten dus beschermd blijven. Hij mag bijvoorbeeld wel het adres van de klant inzien, maar niet de wachtwoord van de klant.
</ol>



<h3 id="opgave173">Verwerkingsopdracht 1.7.3 Fouten voorkomen</h3>

<ol style="list-style-type: lower-alpha">
<li>Gevolgen van verkeerde Delete-rechten bij klanten:
<ul>
<li>Klanten kunnen elkaars of hun eigen bestellingen verwijderen.
<li>Hierdoor kunnen bezorgers en keukenpersoneel hun werk niet goed doen.
<li>Er ontstaat chaos in de bestelgeschiedenis, en klantenservice moet fouten oplossen.
</ul>
<li>Oplossing:
<ul>
<li>Gebruik toegang op basis van rollen (bijv. alleen de beheerder mag DELETE uitvoeren).
<li>Voeg controlemechanismen toe in de applicatie: de knop ‘verwijderen’ is niet zichtbaar voor klanten.
<li>Extra: in een geavanceerde DBMS kun je databasepermissies aanpassen, bijvoorbeeld met GRANT/REVOKE.
</ul>
</ol>


<h3 id="opgave174">Verwerkingsopdracht 1.7.4 CRUD Rechten van de databasebeheerder bepalen</h3>
<ol style="list-style-type: lower-alpha">
<li>Acties: Create, Read, Update, Delete: een beheerder heeft alle rechten.
<li>Voor- en nadelen:
<ul>
<li>Voordelen: De beheerder kan fouten corrigeren, testgegevens verwijderen, of het systeem onderhouden.
<li>Nadelen: Volledige rechten zijn gevoelig voor fouten of misbruik. Eén verkeerde DELETE-query kan veel gegevens verwijderen.
</ul>
</ol>

<!--
<h3 id="opgave181">Verwerkingsopdracht 1.8.1 Gegevens, data en informatie</h3>
Mogelijke antwoorden: <ol style="list-style-type: lower-alpha">
<li>chatGPT: "Gegevens zijn feiten, cijfers en andere waarnemingen die
verzameld en opgeslagen kunnen worden om te worden geanalyseerd,
geïnterpreteerd of gebruikt voor besluitvorming." Met andere woorden,
allerlei eigenschappen van mensen en objecten die je kunt verzamelen en
opslaan om later te gebruiken en/of te combineren tot nuttige
informatie.</li>

<li>chatGPT: "Data bestaat uit feiten, cijfers en waarnemingen die worden
verzameld uit verschillende bronnen en die nog moeten worden geanalyseerd of
geïnterpreteerd om betekenis of waarde te krijgen." Met andere woorden,
opgeslagen eigenschappen van mensen en objecten die je kunt verzamelen en
opslaan om later te gebruiken en/of te combineren tot nuttige
informatie.</li>

<li>chatGPT: "Informatie is de kennis, inzichten, of betekenis die wordt
verkregen door het verzamelen, verwerken, analyseren en interpreteren van
ruwe feiten en cijfers. Het is georganiseerd en gestructureerd zodanig dat
het begrijpelijk en nuttig is voor de ontvanger, en het wordt gebruikt om
beslissingen te nemen, problemen op te lossen of communicatie te verbeteren"
Met andere woorden, informatie bestaat uit het (slim) combineren van data
(gegevens) om zo tot nuttige kennis te komen. Bijvoorbeeld het opstellen van
een profiel van iemand om een persoonlijke advertentie, advies of muziekkeuze
te kunnen geven.</li>

<li>

  <ul>
    <li>Het weerbericht bestaat uit een combinatie van gegevens en data  en dus is het informatie.
    <li>Windsnelheid die wordt gemeten en afgelezen is een gegeven is dat nog niet is opgeslagen. Dus zijn
    het gegevens.
    <li>"Temperatuur gedurende de dag" zijn metingen die elk uur zijn gedaan en zijn opgeslagen. Dus is
    het data.
  </ul>
<li>Ja, in de praktijk worden de woorden data en gegevens veel door elkaar gebruikt.
</ol>
-->
<h1 id="SQL2">Onderwerp 2: SQL SELECT - FROM </h1>
<hr>

<h3 id="opgave221">Verwerkingsopdracht 2.2.1 Alle pizzacodes tonen </h3>
<ol style="list-style-type: lower-alpha">
<li><pre><code class="language-sql">SELECT pizzacode
FROM pizza;</code></pre>
<li>Elke pizzacode komt maar één keer voor. Dat betekent dat elke pizza een unieke code heeft. Zo’n unieke code noemen we een primary key. Een primary key zorgt ervoor dat je elk record in een tabel kunt herkennen. In dit geval herken je elke pizza aan zijn pizzacode.
</ol>

<h3 id="opgave231">Verwerkingsopdracht 2.3.1 Menu printen</h3>
<pre><code class="language-sql">SELECT pizzanaam, omschrijving, basisprijs
FROM pizza;
</code></pre>

<h3 id="opgave241">Verwerkingsopdracht 2.4.1 Alle gegevens van tabel <code>pizza</code> ophalen</h3>
<pre><code class="language-sql">SELECT *
FROM pizza;
</code></pre>

<h3 id="opgave251">Verwerkingsopdracht 2.5.1 Kolom hernoemen</h3>
<pre><code class="language-sql">SELECT naam AS bezorgernaam
FROM bezorger;
</code></pre>


<h3 id="opgave261">Verwerkingsopdracht 2.6.1 Alle gegevens uit tabel <code>klant</code> tonen</h3>
<pre><code class="language-sql">SELECT *
FROM klant;
</code></pre>


<h3 id="opgave271">Verwerkingsopdracht 2.7.1 Prijs met bezorgkosten</h3>
<pre><code class="language-sql">SELECT naam, basisprijs, basisprijs + 0.50 AS totaalprijs
FROM pizza;
</code></pre>

<h3 id="opgave272">Verwerkingsopdracht 2.7.2 Totaalprijs per bestelling</h3>
<pre><code class="language-sql">SELECT aantal, aantal * 8.00 AS totaalprijs
FROM besteldePizza;
</code></pre>


<hr>
<h1 id="SQL2AfOpgaven">Afsluitende Opdrachten Onderwerp 2</h1>


<hr>
<h3 id="opgave291">Afsluitende Opdracht 2.9.1 Kolomnamen opzoeken</h3>
Met de volgende query krijg je een overzicht van de hele
tabel, inclusief de kolomnamen:
<pre><code class="language-sql">SELECT *
FROM bestelling; </code></pre>


<h3 id="opgave292">Afsluitende Opdracht 2.9.2 Menu</h3>
<pre><code class="language-sql">SELECT omschrijving, naam
FROM pizza;
</code></pre>

<h3 id="opgave293">Afsluitende Opdracht 2.9.3 Alle bezorgers bekijken</h3>
<ol style="list-style-type: lower-alpha;">
<li><pre><code class="language-sql">SELECT *
FROM bezorger;
</code></pre>
<li>Mogelijke kolommen:
<ul>
<li>`bezorgernummer`: uniek nummer van elke bezorger
<li>`naam`: de naam van de bezorger
<li>`wachtwoord`: gebruikt voor inloggen in het systeem
</ul>
<li><pre><code class="language-sql">SELECT naam AS bezorgernaam
FROM bezorger;
</code></pre>
</ol>


<h1 id="SQL3">Onderwerp 3: WHERE</h1>


<h3 id="opgave311">Verwerkingsopdracht 3.1.1 Omschrijving van een Inferno pizza tonen </h3>
<pre><code class="language-sql">SELECT omschrijving
FROM pizza
WHERE naam='Inferno'
</code></pre>



<!--

<h3 id="opgave262">Verwerkingsopdracht 2.6.2 Alle klanten uit Enschede tonen</h3>
<pre><code class="language-sql">SELECT adres, postcode, woonplaats
FROM klant
WHERE woonplaats='Enschede'; </code></pre>

<h3 id="opgave263">Verwerkingsopdracht 2.6.3 Wachtwoord van een bezorger tonen</h3>
<pre><code class="language-sql">SELECT wachtwoord
FROM bezorger
WHERE naam = 'Ronald Marbus';
</code></pre>
-->





<h3 id="opgave321">Verwerkingsopdracht 3.2.1 Dure pizza's</h3>
<pre><code class="language-sql">SELECT naam, basisprijs
FROM pizza
WHERE basisprijs >= 9.50;
</code></pre>


<h3 id="opgave322">Verwerkingsopdracht 3.2.2: Geen 8 euro pizza's</h3>
<pre><code class="language-sql">SELECT naam, basisprijs
FROM pizza
WHERE basisprijs <> 8;
</code></pre>


<h3 id="opgave331">Verwerkingsopdracht 3.3.1 Alle pizza's waar de letter 'a' in voorkomt</h3>
<pre><code class="language-sql">SELECT naam
FROM pizza
WHERE naam LIKE '%a%';
</code></pre>


<h3 id="opgave332">Verwerkingsopdracht 3.3.2 Alle klanten met een mobiele telefoonnummer</h3>
<pre><code class="language-sql">SELECT naam, telefoon
FROM klant
WHERE telefoon LIKE '06%';
</code></pre>



<h3 id="opgave361">Verwerkingsopdracht 3.4.1 Pizza's tussen de 8,50 en 10 euro</h3>
<pre><code class="language-sql">SELECT naam, basisprijs
FROM pizza
WHERE basisprijs >= 8.50 AND basisprijs <= 10;
</code></pre>

<h3 id="opgave371">Verwerkingsopdracht 3.5.1 Bestellingen met bestelcode</h3>
<pre><code class="language-sql">SELECT *
FROM bestelling
WHERE bestelcode = 13 OR bestelcode = 30;
</code></pre>


<h3 id="opgave352">Verwerkingsopdracht 3.5.2 Alle goedkope of gezonde pizza's</h3>
<pre><code class="language-sql">SELECT *
FROM pizza
WHERE basisprijs < 7.50 OR omschrijving LIKE '%fruit%';
</code></pre>



<h3 id="opgave361">Verwerkingsopdracht 3.6.1 Alle pizza's zonder kip</h3>
<pre><code class="language-sql">SELECT naam AS pizzanaam, omschrijving
FROM pizza
WHERE omschrijving NOT LIKE '%kip%';
</code></pre>
ook goed:
<pre><code class="language-sql">
ANTWOORD:
SELECT naam, omschrijving
FROM pizza
WHERE NOT omschrijving LIKE '%kip%';
</code></pre>


<h3 id="opgave371">Verwerkingsopdracht 3.7.1 Alle pizza's zonder paprika of ui</h3>

<ol type ="a">
<li>De volgende pizza's worden getoond:
        <ul>
        <li>Prosciutto (ham)
        <li>Funghi (champignons)
        <li>Borromea (ham én champignons)
        <li>Hawaii (ham)
        <li>Calimero (champignons én salami) - Deze hoort er eigenlijk niet bij!
        </ul>
</li>
<li>In SQL wordt de NOT als eerste uitgevoerd, dan AND en dan OR.<br>
Hierdoor wordt de pizza Calimero, die champignons én salami bevat, toch meegenomen. Dat is niet wat de Luna wil.
</li>
<li><pre><code class="language-sql">
SELECT naam, omschrijving
FROM pizza
WHERE (omschrijving LIKE '%ham%' OR omschrijving LIKE '%champignons%')
  AND NOT omschrijving LIKE '%salami%';
</code></pre></li>
<li>Calimero staat nu terecht niet meer in het resultaat, omdat deze salami bevat.</li>
</ol>

<h3 id="opgave372">Verwerkingsopdracht 3.7.2 Toon pizza's die voldoen aan meerdere voorwaarden</h3>
<pre><code class="language-sql">SELECT *
FROM pizza
WHERE basisprijs < 7.5 AND (naam LIKE 'M%' OR naam LIKE '%A');
</code></pre>



<h3 id="opgave391">Verwerkingsopdracht 3.9.1 Query netjes opschrijven</h3>
<ol>
<li>SQL commando in hoofdletters;
<li>Elke SQL commando op een nieuwe regel;
<li>Spatie na de komma: <code>SELECT naam, basisprijs</code> ;
<li>En afsluiten met een ';': <code>WHERE basisprijs < 8;</code>;
<li>Commentaar toevoegen met '--'.
</ol>

<pre><code class="language-sql">
SELECT naam, basisprijs  -- spatie na de komma
FROM pizza               -- Elke SQL commando op een nieuwe regel en in hoofdletters
WHERE basisprijs < 8;    -- afsluiten met een ';'
</code></pre>

<h3 id="opgave3101">Verwerkingsopdracht 3.10.1 Fout in query (1) </h3>
De fout zat in de volgorde van de regels code.
<pre><code class="language-sql">SELECT naam
FROM pizza
WHERE basisprijs < 7.0;
</code></pre>


<h3 id="opgave3102">Verwerkingsopdracht 3.10.2 Fout in query (2)  </h3>
<ol style="list-style-type: lower-alpha">
<li>B. De woonplaatsen zijn met een hoofdletter geschreven (bv.
'Nijmegen'). SQL vergelijkt tekst hoofdlettergevoelig. In dit geval zijn er
klanten die in 'nijmegen' wonen, maar wel in 'Nijmegen'.
<li>
De juiste query is:<pre><code class="language-sql">
  SELECT *
	FROM klant
	WHERE woonplaats = 'Nijmegen'; </code></pre>
</ol>

<h3 id="opgave3103">Verwerkingsopdracht 3.10.3 Fout in query (3)  </h3>
De fout zat in de naam van de tabel.
<pre><code class="language-sql">SELECT naam
FROM pizza
WHERE basispijs < 7.0;
</code></pre>

<h3 id="opgave3104">Verwerkingsopdracht 3.10.4 Fout in query (4))  </h3>
De fout zat in de kolomnaam.
<pre><code class="language-sql">SELECT naam
FROM pizza
WHERE basispijs < 7.0; </code></pre>


<h1 id="SQL3AfOpgaven">Afsluitende Opdrachten Onderwerp 3</h1>

<h3 id="opgave3121">Afsluitende Opdracht 3.12.1 Klanten in een specifieke plaats</h3>
<pre><code class="language-sql">
SELECT klantnummer, naam, woonplaats
FROM klant
WHERE woonplaats = 'Hengelo';
</code></pre>



<h3 id="opgave3122">Afsluitende Opdracht 3.12.2 Debuggen en herschrijven van slordige query</h3>
<pre><code class="language-sql">
-- Er ontbreekt een komma tussen de kolommen.
-- Er ontbreekt een puntkomma aan het eind.
SELECT naam, basisprijs
FROM pizza
WHERE basisprijs < 7;
</code></pre>


<h3 id="opgave3123">Afsluitende Opdracht 3.12.3 Alle goedkope pizza's met een 'C'</h3>
<pre><code class="language-sql">
SELECT naam
FROM pizza
WHERE naam LIKE 'C%' AND basisprijs <= 8.0;
</code></pre>


<h3 id="opgave3124">Afsluitende Opdracht 3.12.4 Dure salami</h3>
<pre><code class="language-sql">
SELECT naam, basisprijs
FROM pizza
WHERE basisprijs >= 9
  AND omschrijving LIKE '%salami%';
</code></pre>

<h3 id="opgave3125">Afsluitende Opdracht 3.12.5 Toon 3 pizza's zonder vlees, met een 'a' in de naam</h3>
<pre><code class="language-sql">
SELECT naam, omschrijving
FROM pizza
WHERE omschrijving NOT LIKE '%ham%'
  AND omschrijving NOT LIKE '%salami%'
  AND omschrijving NOT LIKE '%kip%'
  AND naam LIKE '%a%'
</code></pre>


<h3 id="opgave3126">Afsluitende Opdracht 3.12.6 Pizza's met 'special' of duurder dan €10</h3>
<pre><code class="language-sql">
SELECT naam
FROM pizza
WHERE omschrijving LIKE '%special%'
   OR basisprijs > 9;
</code></pre>


<h3 id="opgave3127">Afsluitende Opdracht 3.12.7 Bezorgers met naam H maar die NIET met J begint</h3>
<pre><code class="language-sql">
SELECT naam AS bezorgernaam
FROM bezorger
WHERE (naam LIKE 'H%' OR naam LIKE 'J%') AND naam NOT LIKE '%A%';
</code></pre>

<h1 id="SQL4">Onderwerp 4: LIMIT, ORDER BY en groepsfuncties</h1>

<h3 id="opgave411">Verwerkingsopdracht 4.1.1 Volgorde van onderdelen</h3>
<ol>
<li>SELECT
<li>FROM
<li>WHERE
<li>ORDER BY
<li>LIMIT
</ol>


<h3 id="opgave421">Verwerkingsopdracht 4.2.1 Alleen de eerste drie pizza's</h3>
<pre><code class="language-sql">
SELECT naam, basisprijs
FROM pizza
LIMIT 3;
</code></pre>



<h3 id="opgave431">Verwerkingsopdracht 4.3.1 de drie duurste pizza's</h3>
<pre><code class="language-sql">
SELECT naam, basisprijs
FROM pizza
ORDER BY basisprijs;
</code></pre>
Ook goed:
<pre><code class="language-sql">
SELECT naam, basisprijs
FROM pizza
ORDER BY basisprijs ASC;
</code></pre>


<h3 id="opgave432">Verwerkingsopdracht 4.3.2 De vijf laatste bezorgingen</h3>
<pre><code class="language-sql">
SELECT bestelcode, bestel_datum
FROM bestelling
ORDER BY bestel_datum DESC
LIMIT 8;
</code></pre>


<h3 id="opgave441">Verwerkingsopdracht 4.5.1 Unieke bezorgdata</h3>
<pre><code class="language-sql">
SELECT DISTINCT bestel_datum
FROM bestelling;
</code></pre>


<h3 id="opgave451">Verwerkingsopdracht 4.6.1 Pizza's tellen</h3>
<pre><code class="language-sql">
SELECT COUNT(besteldepizzacode) AS aantal_bestelde_pizzas
FROM besteldePizza;
</code></pre>

<h3 id="opgave461">Verwerkingsopdracht 4.7.1 Unieke pizzacode's tellen</h3>
<pre><code class="language-sql">
SELECT COUNT(DISTINCT pizzacode) AS aantal_pizzas
FROM besteldePizza;
</code></pre>


<h3 id="opgave471">Verwerkingsopdracht 4.8.1 Vroegste bezorging</h3>
<pre><code class="language-sql">
SELECT MIN(bezorg_tijd) AS vroegste_bezorging
FROM bestelling;
</code></pre>

<h3 id="opgave481">Verwerkingsopdracht 4.9.1 Duurste bodem</h3>
<pre><code class="language-sql">
SELECT MAX(plusprijs) AS hoogste_toeslag
FROM bodem;
</code></pre>

<h3 id="opgave491">Verwerkingsopdracht 4.10.1 Totaal van alle kortingen</h3>
<pre><code class="language-sql">
SELECT SUM(korting) AS totaal_korting
FROM bestelling;
</code></pre>


<h3 id="opgave4101">Verwerkingsopdracht 4.11.1 Gemiddelde toeslag</h3>
<pre><code class="language-sql">
SELECT AVG(plusprijs) AS gemiddelde_bodem_toeslag
FROM bodem;
 </code></pre>

<h1 id="SQL4AfOpgaven">Afsluitende Opdrachten Onderwerp 4</h1>

<h3 id="opgave4121">Afsluitende Opdracht 4.13.1 De drie duurste pizza's</h3>
<pre><code class="language-sql">
SELECT naam, formaatcode, basisprijs
FROM pizza
ORDER BY basisprijs DESC
LIMIT 3;
</code></pre>

<h3 id="opgave4122">Afsluitende Opdracht 4.13.2 Vijf goedkoopste pizza's</h3>
<pre><code class="language-sql">
SELECT naam, basisprijs
FROM pizza
WHERE basisprijs < 8
ORDER BY naam
LIMIT 5;
</code></pre>



<h3 id="opgave4123">Afsluitende Opdracht 4.13.3 Gemiddelde prijs</h3>
<pre><code class="language-sql">
SELECT avg(basisprijs) AS gemiddelde_prijs_zonder_ham
From pizza
WHERE omschrijving NOT LIKE '%ham%';
</code></pre>

<h3 id="opgave4124">Afsluitende Opdracht 4.13.4 Plaatsen met vaste telefoonnummers</li>h3>
<pre><code class="language-sql">
SELECT COUNT(DISTINCT woonplaats) AS woonplaatsen_zonder_06
FROM klant
WHERE telefoon NOT LIKE '06%';
</code></pre>

<h3 id="opgave4125">Afsluitende Opdracht 4.13.5 Aantal normale pizza's</h3>
<pre><code class="language-sql">
SELECT COUNT(pizzacode) AS aantal
FROM pizza
WHERE basisprijs >= 7 AND basisprijs <= 10;
</code></pre>

<h3 id="opgave4126">Afsluitende Opdracht 4.13.6 Totale toeslagen</h3>
<pre><code class="language-sql">
SELECT SUM(plusprijs) AS totaal_toeslagen
FROM formaat
WHERE plusprijs > 1;
</code></pre>

<h3 id="opgave4127">Afsluitende Opdracht 4.13.7</h3>
<pre><code class="language-sql">
SELECT max(basisprijs) AS duurste
FROM pizza
WHERE omschrijving LIKE "%vis%" OR naam LIKE "%a";
</code></pre>


<h1 id="SQL5">Onderwerp 5: JOIN</h1>
<h3 id="opgave511">Verwerkingsopdracht 5.1.1 Koppelingen tussen tabellen </h3>
C. <em>besteldepizza</em> en <em>formaat</em>


<h3 id="opgave521">Verwerkingsopdracht 5.2.1 Nut van een JOIN</h3>

C. Omdat de naam van de pizza niet in tabel <i>besteldepizza</i> staat.


<h3 id="opgave522">Verwerkingsopdracht 5.2.2 BesteldePizza, besteldatum en bezorgtijd</h3>
<pre><code class="language-sql">
SELECT besteldePizza.besteldepizzacode, bestelling.bestel_datum, bestelling.bezorg_tijd
FROM besteldePizza
JOIN bestelling ON besteldePizza.bestelcode = bestelling.bestelcode;
</code></pre>


<h3 id="opgave523">Verwerkingsopdracht 5.2.3 JOIN uitleggen</h3>
Een JOIN koppelt rijen van twee tabellen aan elkaar via een gemeenschappelijke kolom met gelijke waarden. Die kolommen moeten logisch bij elkaar horen en dezelfde soort informatie bevatten.


<h3 id="opgave531">Verwerkingsopdracht 5.3.1: Overzicht van naam en bodem van alle bestelde pizza's</h3>
<pre><code class="language-sql">
SELECT besteldepizza.bestelcode, pizza.naam AS pizzanaam, bodem.omschrijving AS bodembeschrijving
FROM besteldepizza
JOIN pizza ON besteldepizza.pizzacode = pizza.pizzacode
JOIN bodem ON besteldepizza.bodemcode = bodem.bodemcode;
</code></pre>

<h3 id="opgave532">Verwerkingsopdracht 5.3.2: Overzicht van alle pizza's dat elk klant heeft besteld</h3>
<pre><code class="language-sql">
SELECT klant.naam, klant.postcode, besteldePizza.pizzacode
FROM klant
JOIN bestelling ON klant.klantnummer = bestelling.klantnummer
JOIN besteldePizza ON bestelling.bestelcode = besteldePizza.bestelcode;
</code></pre>



<h1 id="SQL5AfOpgaven">Afsluitende Opdrachten Onderwerp 5</h1>

<h3 id="opgave551">Afsluitende Opdracht 5.5.1 Omschrijving van de bodem bij een bestelling</h3>

<pre><code class="language-sql">
SELECT besteldepizza.besteldepizzacode, bodem.omschrijving
FROM besteldepizza
JOIN bodem ON besteldepizza.bodemcode = bodem.bodemcode;
</code></pre>




<h3 id="opgave552">Afsluitende Opdracht 5.5.2 Een overzicht van de bestelde pizza en het formaat</h3>
<pre><code class="language-sql">
SELECT
  besteldePizza.besteldepizzacode,
  pizza.naam AS pizzanaam,
  formaat.omschrijving AS formaat
FROM besteldePizza
JOIN pizza ON besteldePizza.pizzacode = pizza.pizzacode
JOIN formaat ON besteldePizza.formaatcode = formaat.formaatcode;
</code></pre>

<h3 id="opgave553">Afsluitende Opdracht 5.5.3 Wie heeft welke pizza besteld?</h3>
<pre><code class="language-sql">SELECT klant.naam, pizza.naam
FROM klant
JOIN bestelling ON klant.klantnummer = bestelling.klantnummer
JOIN besteldePizza ON bestelling.bestelcode = besteldePizza.bestelcode
JOIN pizza ON besteldePizza.pizzacode = pizza.pizzacode;
</code></pre>

<h3 id="opgave554">Afsluitende Opdracht 5.5.4 Bestellingen van klanten uit Enschede of Hengelo</h3>
<pre><code class="language-sql">
SELECT bestelcode, bestelling.klantnummer
FROM bestelling
JOIN klant  ON bestelling.klantnummer = klant.klantnummer
WHERE woonplaats = 'Enschede' OR woonplaats = 'Hengelo'
LIMIT 3;
</code></pre>

<h3 id="opgave535">Afsluitende Opdracht 5.5.5 Bezorgerinformatie</h3>
<pre><code class="language-sql">
SELECT
    bezorger.naam AS bezorgernaam,
    klant.naam AS klantnaam,
    klant.adres,
    klant.postcode,
    klant.woonplaats
FROM bestelling
JOIN bezorger ON bestelling.bezorgernummer = bezorger.bezorgernummer
JOIN klant ON bestelling.klantnummer = klant.klantnummer
LIMIT 5;
</code></pre>

<h3 id="opgave556">Afsluitende Opdracht 5.5.6 Voor de kok</h3>
<pre><code class="language-sql">
SELECT
    pizza.naam AS pizzanaam,
    formaat.omschrijving AS formaat,
    bodem.omschrijving AS bodem
FROM besteldePizza
JOIN pizza ON besteldePizza.pizzacode = pizza.pizzacode
JOIN formaat ON besteldePizza.formaatcode = formaat.formaatcode
JOIN bodem ON besteldePizza.bodemcode = bodem.bodemcode
LIMIT 10;
</code></pre>


<h1 id="SQL6">Onderwerp 6: Create - Read - Update - Delete</h1>


<h3 id="opgave711">Verwerkingsopdracht 6.1.1 Pizza toevoegen en controleren</h3>
<ol type="a">
  <li><pre><code class="language-sql">INSERT INTO pizza
VALUES (NULL, 'Pizza Hawaii', 'Ham en ananas', 8.50);
</code></pre>
<li><pre><code class="language-sql">-- check:
SELECT *
FROM pizza;
</code></pre>
</ol>

<h3 id="opgave712">Verwerkingsopdracht 6.1.2 Een nieuwe glutenvrije bodem</h3>
Antwoord: B<br>
Toelichting: bodemcode is een AUTOINCREMENT-veld en moet je dus NULL invullen.
Bij antwoord D ontbreken aanhalingstekens en het euroteken is fout in SQL.



<h3 id="opgave713">Verwerkingsopdracht 6.1.3 Pan-bodem toevoegen</h3>
<pre><code class="language-sql">
INSERT INTO formaat
VALUES (NULL, 'XXL', 2.00);
-- check:
SELECT *
FROM formaat;
</code></pre>


<h3 id="opgave722"> Verwerkingsopdracht 6.2.2 Verwijder de Pazza pizza</h3>
<pre><code class="language-sql">
UPDATE pizza
SET basisprijs = 8.00
WHERE naam = "Pazza";
-- check:
SELECT *
FROM pizza;
</code></pre>

<h3 id="opgave731"> Verwerkingsopdracht 6.3.1 Pas de prijs van een pizza aan</h3>
<pre><code class="language-sql">
UPDATE pizza
SET basisprijs = 8.00
WHERE naam = "Margherita";
</code></pre>


<h3 id="opgave741"> Verwerkingsopdracht 6.4.1 Nieuwe tabel kortingsbon aanmaken</h3>
<ol type="a">
<li>
<pre><code class="language-sql">
CREATE TABLE kortingsbon (
    boncode INTEGER PRIMARY KEY AUTOINCREMENT,
    korting REAL,
    datum TEXT
);
</code></pre>
</li>
<li>
Als de code geen foutmelding geeft, maar wel een lege tabel oplevert, dan is het aanmaken gelukt. Met <code>CREATE TABLE</code> heb je alleen de tabel aangemaakt. Met <code>INSERT INTO</code> kun je daarna gegevens invoeren.
</li>
<li><pre><code class="language-sql">INSERT INTO kortingsbon VALUES (NULL,0.50,"2025-12-20");</code></pre></li>

</ol>



<h3 id="opgave751"> Verwerkingsopdracht 6.5.1 Verwijder tabel bodem</h3>
<ol type="a">
<li>
<pre><code class="language-sql">
-- verwijderen:
DROP TABLE bodem;
</code></pre>
<li>
<pre><code class="language-sql">
-- check:
SELECT *
FROM bodem;-- ophalen lukt niet omdat de tabel in de vorige stap verwijderd is.
</code></pre>
</ol>



<h3 id="opgave761"> Verwerkingsopdracht 6.6.1 Kolom geboortedatum toevoegen</h3>
<pre><code class="language-sql">
ALTER TABLE klant
ADD geboortedatum TEXT;
</code></pre>

<h3 id="opgave771"> Verwerkingsopdracht 6.7.1 Kolom <b>naam</b> hernoemen naar <b>klantnaam</b></h3>
<pre><code class="language-sql">
ALTER TABLE klant
RENAME COLUMN naam TO klantnaam;
</code></pre>

<h3 id="opgave781"> Verwerkingsopdracht 6.8.1 Tabel hernoemen naar grootte</h3>
<pre><code class="language-sql">
ALTER TABLE formaat
RENAME TO grootte;
</code></pre>




<h3 id="opgave7101">Verwerkingsopdracht 6.9.1 Foreign keys bij Danilo's Pizzeria</h3>
<ol type="a">
<li>De tabel <i>besteldepizza</i> heeft vier foreign keys, namelijk:
	<ol><li><b>bestelcode</b> uit tabel <i>bestelling</i>
<li><b>pizzacode</b> uit tabel <i>pizza</i>
<li><b>bodemcode</b> uit tabel <i>bodem</i>
<li><b>formaatcode</b> uit tabel <i>formaat</i>
	</ol>
<li>De tabel <i>formaat</i> heeft <b>geen</b> foreign key. Ze heeft een primary key <b>formaatcode</b> die vanuit tabel <i>besteldePizza</i> als foreign key gebruikt wordt, maar ze verwijst zelf niet naar een andere tabel en heeft dus geen foreign key.
</ol>

<h3 id="opgave7111">Verwerkingsopdracht 6.10.1 Foreign keys bij Danilo's Pizzeria</h3>
<ol type="a">

<li>Tabel <i>besteldePizza</i> heeft een kolom <b>formaatcode</b>. Daarvoor komen de gegevens uit de tabel <i>formaat</i> en de primary key-kolom <b>formaatcode</b>.
<li>De foreign key verwijst naar kolom <b>omschrijving</b> uit de tabel <i>bodem</i>. Dit is niet correct, want een foreign key moet verwijzen naar de primary key van de tabel <i>bodem</i>, en dus <b>bodemcode</b>.
</ol>

<h3 id="opgave7112">Verwerkingsopdracht 6.10.2 Debuggen van een foutieve foreign key</h3>
De <b>boncode</b> in de tabel <i>kortingsbon</i> is de primary key. Maar de code van de foreign key staat in de <code>CREATE TABLE</code> van de tabel <i>kortingsbon</i>. Dat is niet goed.<br>

Deze primary key uit de tabel <i>kortingsbon</i> moet worden gekoppeld aan een kolom in een andere tabel, namelijk tabel <i>bestelling</i>. De code voor de foreign key moet dus in de <code>CREATE TABLE</code> van tabel <i>bestelling</i> worden toegevoegd.

<h3 id="opgave7113">Verwerkingsopdracht 6.10.3 Foreign key teovoegen</h3>

<ol type="a">
<li>
De code voor de ontbrekende foreign key is:
<code>FOREIGN KEY(klantnummer) REFERENCES klant(klantnummer)</code>
<br>

De complete SQL code voor het maken van de tabel <i>bestelling</i> is dan:
<pre><code class="language-sql">
CREATE TABLE bestelling (
  bestelcode INTEGER PRIMARY KEY NOT NULL,
  bestel_datum TEXT,
  bestel_tijd TEXT,
  bezorg_tijd TEXT,
  bezorgernummer INTEGER NOT NULL,
  klantnummer INTEGER NOT NULL,
  boncode INTEGER,
  FOREIGN KEY(bezorgernummer) REFERENCES bezorger(bezorgernummer)
  FOREIGN KEY(klantnummer) REFERENCES klant(klantnummer)
) ;
</code></pre>
</li>
<li>De kolom <b>bestelcode</b> is een primary key in de tabel <i>bestelling</i>. De foreign key moet dus in de <code>CREATE TABLE</code> van tabel <i>besteldePizza</i> staan.</li>
</ol>

<h3 id="opgave7131">Afsluitende Opdracht 6.12.1 Keys bepalen</h3>
<ol type="a">
<li>Kolom <b>reviewcode</b></li>
<li>De tabel <i>review</i></li>
</ol>


<h3 id="opgave7132">Afsluitende Opdracht 6.12.2 Tabel <i>review</i> aanmaken</h3>
<ol type="a">
<li><pre><code>CREATE TABLE review (
    reviewcode INTEGER PRIMARY KEY AUTOINCREMENT,
    pizzacode INTEGER,
    beoordeling INTEGER,
    opmerking TEXT,
    FOREIGN KEY (pizzacode) REFERENCES pizza(pizzacode)
);</code></pre>
</li>
<li><pre><code>INSERT INTO review (pizzacode, beoordeling, opmerking) VALUES
(11, 8, 'Lekkere bodem en goed belegd.'),
(7, 6, 'Beetje te pittig naar mijn smaak.'),
(2, 9, 'Heerlijke kaascombinatie!');</code></pre>
</li>
<li><pre><code>SELECT *
FROM review;</code></pre></li>
</ol>



<h3 id="opgave7133">Afsluitende Opdracht 6.12.3 Reviews verwijderen en aanpassen</h3>
<ol type="a">
<li><pre><code class="language-sql">DELETE FROM review WHERE reviewcode = 2;
</pre></code>
</li>
<li><pre><code class="language-sql">UPDATE review
SET beoordeling = 9
WHERE reviewcode = 1;</pre></code>
</li>
<li><pre><code>SELECT *
FROM review;</code></pre></li>
<li>Als je een DELETE-query zonder WHERE gebruikt, worden alle rijen uit de tabel verwijderd. De hele tabel wordt dan geleegd, maar de tabel zelf blijft bestaan.</li>
</ol>


<h3 id="opgave7134">Afsluitende Opdracht 6.12.4 Kolom <b>datum</b> toevoegen
<ol type="a">
<li><pre><code class="language-sql">
ALTER TABLE review ADD COLUMN datum TEXT;
</code></pre>
</li>
<li><pre><code class="language-sql">
UPDATE review SET datum = '2025-07-30' where reviewcode = 1;
UPDATE review SET datum = '2025-08-15' where reviewcode = 3;
</code></pre>
</li>
<li><pre><code>SELECT *
FROM review;</code></pre></li>
</ol>

<h3 id="opgave7135">Afsluitende Opdracht 6.12.5 Kolom <b>opmerking</b> hernoemen</h3>
<ol type="a">
<li>
<pre><code class="language-sql">ALTER TABLE review RENAME COLUMN opmerking TO toelichting;
</code></pre>
</li>
<li><pre><code class="language-sql">SELECT *
FROM beoordeling;
</code></pre></li>
</ol>

<h3 id="opgave7136">Afsluitende Opdracht 6.12.6 Tabel <i>review</i> hernoemen</h3>
<ol type="a">
<li><pre><code class="language-sql">
ALTER TABLE review RENAME TO beoordeling;
</code></pre>
</li>
<li><pre><code class="language-sql">SELECT *
FROM beoordeling;
</code></pre></li>
</ol>

<h3 id="opgave7137">Afsluitende Opdracht 6.12.7 Tabel <i>beoordeling</i> verwijderen</h3>
<ol type="a">
<li><pre><code class="language-sql">
DROP TABLE beoordeling;
</code></pre>
</li>
<li><pre><code class="language-sql">SELECT *
FROM beoordeling;
</code></pre></li>
</ol>


<!--

<h3 id="opgave7131">Afsluitende Opdracht 6.13.1 Nieuwe pizza</h3>
<pre><code>INSERT INTO pizza
VALUES (NULL, 'Pizza Tonno', 'Tomaat, kaas en tonijn', 7.90);</code></pre>



      <td><strong>2. Verhoog prijs Margherita naar €6,50</strong></td>
      <td><pre><code>UPDATE pizza
SET basisprijs = 6.50
WHERE naam = 'Margherita';</code></pre></td>
    </tr>
    <tr>
      <td><strong>3. Verwijder bestelling met bestelcode 999</strong></td>
      <td><pre><code>DELETE FROM bestelling
WHERE bestelcode = 999;</code></pre></td>
    </tr>
    <tr>
      <td><strong>4. Zoek naar pizza’s met "shoarma"</strong></td>
      <td><pre><code>SELECT * FROM pizza
WHERE naam LIKE '%shoarma%'
   OR omschrijving LIKE '%shoarma%';</code></pre></td>
    </tr>
    <tr>
      <td><strong>5. Voeg nieuwe bestelling toe voor klant 3 (pizza 8, bezorger 2)</strong></td>
      <td>
<pre><code>-- Stap 1: bestelling invoeren
INSERT INTO bestelling
VALUES (NULL, 3, 2, '2025-07-29 12:00:00');

-- Stap 2: pizza koppelen (stel bestelcode = 105)
INSERT INTO besteldePizza
VALUES (NULL, 105, 8);</code></pre>
      </td>
    </tr>
  </tbody>
</table>


-->




<h1 id="SQL7">Onderwerp 7: GROUP BY, HAVING</h1>
<h3 id="opgave661">Verwerkingsopdracht 7.1.1 Volgorde van onderdelen</h3>
<ol>
<li>SELECT</li>
<li>FROM</li>
<li>WHERE</li>
<li>ORDER BY</li>
<li>LIMIT</li>
</ol>





<h3 id="opgave621"> Verwerkingsopdracht 7.2.1 Bestelde pizzasoorten</h3>

<pre><code class="language-sql">
SELECT pizzacode, AVG(aantal) AS gemiddeld_aantal
FROM besteldepizza
GROUP BY pizzacode;
</code></pre>



<h3 id="opgave622"> Verwerkingsopdracht 7.2.2 Aantal bestellingen per bodemcode</h3>

<pre><code class="language-sql">
SELECT bodemcode, COUNT(*)
FROM besteldepizza
GROUP BY bodemcode;
</code></pre>


<h3 id="opgave623">Verwerkingsopdracht 7.2.3 Meest pizza's van één soort</h3>


<pre><code class="language-sql">
SELECT bestelcode, MAX(aantal) AS max_aantal
FROM besteldePizza
GROUP BY bestelcode;
</code></pre>



<h3 id="opgave631"> Verwerkingsopdracht 7.3.1 Bestelde bodems</h3>

<pre><code class="language-sql">
SELECT bodemcode, COUNT(*) as aantal_besteld_per_bodem
FROM besteldepizza
GROUP BY bodemcode
HAVING COUNT(*) > 1;
</code></pre>



<h3 id="opgave632"> Verwerkingsopdracht 7.3.2 Ervaren bezorgers</h3>
<pre><code class="language-sql">
SELECT bezorgernummer
FROM bestelling
GROUP BY bezorgernummer
HAVING COUNT(*) > 150;
</code></pre>



<h3 id="opgave633"> Verwerkingsopdracht 7.3.3 Bodems met meer dan 2000 bestellingen</h3>

<pre><code class="language-sql">
SELECT bodemcode, COUNT(*) AS aantal_bestellingen
FROM besteldePizza
GROUP BY bodemcode
HAVING COUNT(*) > 2000;
</code></pre>




<h3 id="opgave641"> Verwerkingsopdracht 7.4.1 Verschil tussen WHERE en HAVING</h3>
<ol type="a">
<li>WHERE-filter op rij-niveau:<br><pre><code class="language-sql">
SELECT *
FROM besteldepizza
WHERE bodemcode = 1;
</code></pre></li>

<li>HAVING-filter op groep-niveau:<br><pre><code class="language-sql">
SELECT bodemcode, COUNT(*) AS aantal
FROM besteldepizza
GROUP BY bodemcode
HAVING COUNT(*) > 1;</code></pre></li>
<li>Her verschil tussen WHERE en HAVING:
<ul>
<li>WHERE gebruik je als je rijen wilt uitsluiten voordat je gaat tellen of groeperen.
<li>HAVING gebruik je als je groepen wilt filteren nadat je hebt geteld of iets hebt samengevat.
</ul></li>
</ol>

<h3 id="opgave642"> Verwerkingsopdracht 7.4.2 Bodems die vaak zijn besteld (maar zonder kleine bestellingen)</h3>

<pre><code class="language-sql">
SELECT bodemcode, SUM(aantal) AS totaal_besteld
FROM besteldePizza
WHERE aantal > 1             -- filter op rij-niveau vóór de GROUP BY
GROUP BY bodemcode
HAVING SUM(aantal) > 2000;    -- filter ná de GROUP BY
</code></pre>


<h1 id="SQL7AfOpgaven">Afsluitende Opdrachten Onderwerp 7</h1>

<h3 id="opgave661">  Afsluitende Opdracht 7.6.1 Aantal bestellingen per bodem</h3>
<pre><code class="language-sql">
SELECT bodemcode, COUNT(*) AS aantal_besteld_per_bodem
FROM besteldePizza
GROUP BY bodemcode
ORDER BY aantal_besteld_per_bodem DESC;
</code></pre>

<h3 id="opgave662">  Afsluitende Opdracht 7.6.2 Bekijk hoe vaak een specifieke bodem is gebruikt</h3>
<pre><code>SELECT bodemcode, COUNT(*) AS aantal_besteld
FROM besteldepizza
WHERE bodemcode = 2
GROUP BY bodemcode
HAVING COUNT(*) > 1
ORDER BY aantal_besteld DESC
LIMIT 1;
</code></pre>

<h3 id="opgave663">Afsluitende Opdracht 7.6.3 Totale aantal pizza’s per klant</h3>

<pre><code class="language-sql">SELECT bestelling.klantnummer, SUM(besteldePizza.aantal)
FROM bestelling
JOIN besteldePizza ON bestelling.bestelcode = besteldePizza.bestelcode
GROUP BY bestelling.klantnummer;
</code></pre>

<h3 id="opgave664">Afsluitende Opdracht 7.6.4 Meest bestelde pizzabodem</h3>
<pre><code class="language-sql">SELECT bodemcode, COUNT(*) as aantal_besteld
FROM besteldepizza
GROUP BY bodemcode
ORDER BY aantal_besteld DESC
LIMIT 1;
</code></pre>


</body>
</html>
